{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Async+ for Swift provides a simple chainable interface for your async and throwing code, similar to promises and futures. This allows you to use the async solution built into the language, but keep all the useful features of promises, such as recover , catching-behavior-as-a-function, and ensure . Contents \u00b6 Getting Started Operations Async/Throwing Interoperability Motivation and common patterns Cancellation Migrating from PromiseKit FAQ Other Resources \u00b6 For any questions on Async+ or feedback on this documentation, please use the Async+ Discord .","title":"Welcome"},{"location":"#welcome","text":"Async+ for Swift provides a simple chainable interface for your async and throwing code, similar to promises and futures. This allows you to use the async solution built into the language, but keep all the useful features of promises, such as recover , catching-behavior-as-a-function, and ensure .","title":"Welcome"},{"location":"#contents","text":"Getting Started Operations Async/Throwing Interoperability Motivation and common patterns Cancellation Migrating from PromiseKit FAQ","title":"Contents"},{"location":"#other-resources","text":"For any questions on Async+ or feedback on this documentation, please use the Async+ Discord .","title":"Other Resources"},{"location":"async-or-throwing-contexts/","text":"Using chains from async or throwing contexts \u00b6 Async contexts, async throwing contexts \u00b6 Waiting for a chain to complete from within an async or async throwing function is possible as in: let value = await attempt{ ... }.async() let value = try await attempt{ ... }.asyncThrows() These value-getting operations are available anywhere in the chain, even after .finally . If the chain doesn't throw you will not be able to call asyncThrows on it (it is a Guarantee<T> type rather than a Promise<T> type), and vice versa. Throwing contexts \u00b6 Additionally, a throws() operation exists for non-async throwing contexts. For non-async chains, no Tasks are created under the hood, and all operations run sychronously. Here is an example that returns a value using .throws() : func myThrowingFunc () throws { let v = try attempt { ... }. then { ... }. recoverEtc { ... }. throws () // Do something with v }","title":"Async/Throwing Interoperability"},{"location":"async-or-throwing-contexts/#using-chains-from-async-or-throwing-contexts","text":"","title":"Using chains from async or throwing contexts"},{"location":"async-or-throwing-contexts/#async-contexts-async-throwing-contexts","text":"Waiting for a chain to complete from within an async or async throwing function is possible as in: let value = await attempt{ ... }.async() let value = try await attempt{ ... }.asyncThrows() These value-getting operations are available anywhere in the chain, even after .finally . If the chain doesn't throw you will not be able to call asyncThrows on it (it is a Guarantee<T> type rather than a Promise<T> type), and vice versa.","title":"Async contexts, async throwing contexts"},{"location":"async-or-throwing-contexts/#throwing-contexts","text":"Additionally, a throws() operation exists for non-async throwing contexts. For non-async chains, no Tasks are created under the hood, and all operations run sychronously. Here is an example that returns a value using .throws() : func myThrowingFunc () throws { let v = try attempt { ... }. then { ... }. recoverEtc { ... }. throws () // Do something with v }","title":"Throwing contexts"},{"location":"cancellation/","text":"Cancellation \u00b6 Cancellation is possible through a chained item's exposed task property, which returns a Task<T> that corresponds to the operation of the chain item AND all previous items in the chain. This task can then be cancelled using Swift's standard mechanism for cancellation . You might think that the task of a chained item resulting from catch is never run, but tasks always runs regardless of success or failure of the chain of operations. Chained items that are instantaneously evaluated (e.g. AsyncPlus.Result<T> ) do not have a \"task\" that can be cancelled, but have a result or value instead.","title":"Cancellation"},{"location":"cancellation/#cancellation","text":"Cancellation is possible through a chained item's exposed task property, which returns a Task<T> that corresponds to the operation of the chain item AND all previous items in the chain. This task can then be cancelled using Swift's standard mechanism for cancellation . You might think that the task of a chained item resulting from catch is never run, but tasks always runs regardless of success or failure of the chain of operations. Chained items that are instantaneously evaluated (e.g. AsyncPlus.Result<T> ) do not have a \"task\" that can be cancelled, but have a result or value instead.","title":"Cancellation"},{"location":"faq/","text":"FAQ \u00b6 Why am I getting an unused value warning from Xcode? Chains that allow failures to go uncaught (without .catch or .recover ) will raise an \"unused result\" warning at compile time if they are not assigned to a variable and used. Similarly, unused results returned from then or recover will raise a warning. What is the difference between the ensure operation and using Swift's built-in defer ? Swift's defer will execute the provided block at the end of the current scope. This is different from ensure , which executes regardless of success or failure at the place that it is put in the chain . Although defer preserves order of execution with regard to other defer statements, this order is not in relation to the surrounding await operations like ensure is. Additionally, if a function throws before defer is called, then the block will not be run at all. Even though at first glance they may be used for similar things (e.g. cleaning up of resources), they behave quite differently with respect to when and if they are run.","title":"FAQ"},{"location":"faq/#faq","text":"Why am I getting an unused value warning from Xcode? Chains that allow failures to go uncaught (without .catch or .recover ) will raise an \"unused result\" warning at compile time if they are not assigned to a variable and used. Similarly, unused results returned from then or recover will raise a warning. What is the difference between the ensure operation and using Swift's built-in defer ? Swift's defer will execute the provided block at the end of the current scope. This is different from ensure , which executes regardless of success or failure at the place that it is put in the chain . Although defer preserves order of execution with regard to other defer statements, this order is not in relation to the surrounding await operations like ensure is. Additionally, if a function throws before defer is called, then the block will not be run at all. Even though at first glance they may be used for similar things (e.g. cleaning up of resources), they behave quite differently with respect to when and if they are run.","title":"FAQ"},{"location":"getting-started/","text":"Getting Started \u00b6 Installation \u00b6 Async+ can be installed using either SwiftPM or Cocoapods. With Xcode (SwiftPM) Install the Async+ package in Xcode by going to <your project> -> <ProjectName> -> Package Dependencies -> \"+\" and entering: https://github.com/async-plus/async-plus.git in the search bar in the top right corner of the window. With Package.swift (SwiftPM) If you are developing a Swift package or a Linux-based Swift application you will have a Package.swift file. Modify it to match the pattern below, updating the major and minor version numbers to the latest version of Async+ (which you can find here ): dependencies : [ . Package ( url : \"https://github.com/async-plus/async-plus.git\" , majorVersion : 1 , minor : 1 ), ] The above example uses version 1.1. With CocoaPods For CocoaPods, in your Podfile , add the \"AsyncPlus\" pod and version number to a target as in the following example: target \"Change Me!\" do pod \"AsyncPlus\", \"~> 1.1\" end Importing Async+ To use Async+ you must import it with import AsyncPlus . Basic Usage \u00b6 Basic chaining operations are: .then arranges blocks one after another, passing along any values .recover recovers from a thrown error with a backup value (or block to run) .catch catches any errors (and allows you to throw new ones for later catch blocks) attempt { ... } kicks off a chain as in the example below: attempt { return try await getThing () }. recover { error in return try await backupGetThing ( error ) }. then { thing in await thing . doYour () }. catch { error in alert ( error ) } To play around with the API you may find it useful to use the convenience after function, which waits a provided number of seconds: attempt { await after ( 2.0 ) return \"Hello \" }. then { hello in print ( hello + \"World\" ) }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"Async+ can be installed using either SwiftPM or Cocoapods. With Xcode (SwiftPM) Install the Async+ package in Xcode by going to <your project> -> <ProjectName> -> Package Dependencies -> \"+\" and entering: https://github.com/async-plus/async-plus.git in the search bar in the top right corner of the window. With Package.swift (SwiftPM) If you are developing a Swift package or a Linux-based Swift application you will have a Package.swift file. Modify it to match the pattern below, updating the major and minor version numbers to the latest version of Async+ (which you can find here ): dependencies : [ . Package ( url : \"https://github.com/async-plus/async-plus.git\" , majorVersion : 1 , minor : 1 ), ] The above example uses version 1.1. With CocoaPods For CocoaPods, in your Podfile , add the \"AsyncPlus\" pod and version number to a target as in the following example: target \"Change Me!\" do pod \"AsyncPlus\", \"~> 1.1\" end Importing Async+ To use Async+ you must import it with import AsyncPlus .","title":"Installation"},{"location":"getting-started/#basic-usage","text":"Basic chaining operations are: .then arranges blocks one after another, passing along any values .recover recovers from a thrown error with a backup value (or block to run) .catch catches any errors (and allows you to throw new ones for later catch blocks) attempt { ... } kicks off a chain as in the example below: attempt { return try await getThing () }. recover { error in return try await backupGetThing ( error ) }. then { thing in await thing . doYour () }. catch { error in alert ( error ) } To play around with the API you may find it useful to use the convenience after function, which waits a provided number of seconds: attempt { await after ( 2.0 ) return \"Hello \" }. then { hello in print ( hello + \"World\" ) }","title":"Basic Usage"},{"location":"migrating-from-promisekit/","text":"Migrating from PromiseKit \u00b6 Similarities \u00b6 Below are some PromiseKit operations and their equivalents in Async+: firstly -> attempt then -> then (but it doesn't always need to return a value) map -> then with a non-async body returning a value compactMap -> use then returning a value, combined with a helper extension for optional called unwrapOrThrow . Use this on the optional value when you return to replicate the behavior of compactMap . recover -> recover get -> then that doesn't return anything tap -> tap (not implemented yet) ensure -> ensure done -> then without returning a value catch -> catch finally -> finally Differences \u00b6 Additionally, these operations offer functionality that is different from PromiseKit: .catch() with throwing body: this essentially just maps errors to one another while preventing further calls to then . .throws() : If the chain is able to be evaluated instantaneously, then this returns the value or throws. .async() : Can use on a guarantee (which is returned by a non-throwing recover ). .asyncOptional() : For failable async chains: Async call that returns an optional value of the result. .asyncResult() : Async call that returns a Swift.Result<T, Error> (the Async+ framework defines its own result type). .asyncThrows() : Async call that returns the value or throws.","title":"Migrating from PromiseKit"},{"location":"migrating-from-promisekit/#migrating-from-promisekit","text":"","title":"Migrating from PromiseKit"},{"location":"migrating-from-promisekit/#similarities","text":"Below are some PromiseKit operations and their equivalents in Async+: firstly -> attempt then -> then (but it doesn't always need to return a value) map -> then with a non-async body returning a value compactMap -> use then returning a value, combined with a helper extension for optional called unwrapOrThrow . Use this on the optional value when you return to replicate the behavior of compactMap . recover -> recover get -> then that doesn't return anything tap -> tap (not implemented yet) ensure -> ensure done -> then without returning a value catch -> catch finally -> finally","title":"Similarities"},{"location":"migrating-from-promisekit/#differences","text":"Additionally, these operations offer functionality that is different from PromiseKit: .catch() with throwing body: this essentially just maps errors to one another while preventing further calls to then . .throws() : If the chain is able to be evaluated instantaneously, then this returns the value or throws. .async() : Can use on a guarantee (which is returned by a non-throwing recover ). .asyncOptional() : For failable async chains: Async call that returns an optional value of the result. .asyncResult() : Async call that returns a Swift.Result<T, Error> (the Async+ framework defines its own result type). .asyncThrows() : Async call that returns the value or throws.","title":"Differences"},{"location":"motivation-and-common-patterns/","text":"Motivation and Common Patterns \u00b6 Motivation \u00b6 Async/await is the future of asynchronous coding in Swift. It's missing a few crucial patterns however. Most notably, patterns such as retrying and ensured execution regardless failure status are unwieldy without promises/futures, and catching behavior is much less modular. Promise-like chaining with Async+ fixes these issues: Example: Recovery \u00b6 attempt { return try await getThing () }. recover { error in return try await backupGetThing ( error ) }. then { thing in await thing . doYour () }. catch { error in alert ( error ) } For comparison, if we tried to write the above flow without Async+ we'd get something like this: Task . init { do { let thing : Thing do { thing = try await getThing () } catch { thing = try await backupGetThing ( error ) } await thing . doYour () } catch { error in alert ( error ) } } Async+ allows async and/or throwing code to remain unnested, modular, and concise. Example: Modular failure blocks \u00b6 Async+ allows us to add catch behavior at any level of a failable operation. For example, we could create methods printingFailure and alertingFailure as follows, in order to encapsulate different things that we might want to trigger when an error occurs: import AsycPlus extension Catchable { /// Prints the error that caused failure func printingFailure () -> SelfCaught { return self . catchEscaping { error in print ( error . localizedDescription ) } } /// Displays an alert to the user about the failure func alertingFailure () -> SelfCaught { return self . catchEscaping { alert ( error . localizedDescription ) } } } We can then use .printingFailure and .alertingFailure for both synchronous and asynchronous chains (corresponding to types Result<T> and Promise<T> ). For example, using our function .alertingFailure synchronously could look like this: let result = attempt { guard let something = something else { throw MockError . notImplemented } // ... }. alertingFailure (). result // do something with result Or we could use .alertingFailure asynchronously as well: let resultInt : Int = try await attempt { () -> Int guard let something = something else { throw MockError . notImplemented } // ... return 0 }. alertingFailure (). asyncThrows () Note You can see we use catchEscaping rather than catch when passing a non-async closure in a protocol context. This is the only time that catchEscaping should be preferred. The performance boost using catchEscaping is probably negligible though. If you'd like to keep it simple and only ever use catch , you would write the extension returning a CaughtPromise<T> or a PartiallyCaughtPromise<T> as follows: extension Catchable { func printingFailure () -> CaughtPromise < T > { return self . catch { error in print ( error . localizedDescription ) } } } // OR extension Catchable { func printingRethrowingFailure () -> PartiallyCaughtPromise < T > { return self . catch { error in print ( error . localizedDescription ) throw error } } } The only difference here is that the body passed to self.catch is treated as async , so a caught or uncaught variant of a Promise<T> is always returned. This means that you will never be able to call .result on the output as demonstrated earlier, but will have to use .asyncResult instead. Common Patterns \u00b6 How do I... Run two chains in parallel? \u00b6 async let value1 = attempt{ ... }.async() async let value2 = attempt{ ... }.async() You then round up the results by calling let values = await [value1, value2]) Use a chained result with guard statements? \u00b6 guard let v : Person ? = await attempt { return try await api . GetPerson () }. recover { return try await localCache . GetPerson () }. catch { error in logger . error ( \"We could not get a person\" ) }. asyncOptional () else { }","title":"Motivation and Common Patterns"},{"location":"motivation-and-common-patterns/#motivation-and-common-patterns","text":"","title":"Motivation and Common Patterns"},{"location":"motivation-and-common-patterns/#motivation","text":"Async/await is the future of asynchronous coding in Swift. It's missing a few crucial patterns however. Most notably, patterns such as retrying and ensured execution regardless failure status are unwieldy without promises/futures, and catching behavior is much less modular. Promise-like chaining with Async+ fixes these issues:","title":"Motivation"},{"location":"motivation-and-common-patterns/#example-recovery","text":"attempt { return try await getThing () }. recover { error in return try await backupGetThing ( error ) }. then { thing in await thing . doYour () }. catch { error in alert ( error ) } For comparison, if we tried to write the above flow without Async+ we'd get something like this: Task . init { do { let thing : Thing do { thing = try await getThing () } catch { thing = try await backupGetThing ( error ) } await thing . doYour () } catch { error in alert ( error ) } } Async+ allows async and/or throwing code to remain unnested, modular, and concise.","title":"Example: Recovery"},{"location":"motivation-and-common-patterns/#example-modular-failure-blocks","text":"Async+ allows us to add catch behavior at any level of a failable operation. For example, we could create methods printingFailure and alertingFailure as follows, in order to encapsulate different things that we might want to trigger when an error occurs: import AsycPlus extension Catchable { /// Prints the error that caused failure func printingFailure () -> SelfCaught { return self . catchEscaping { error in print ( error . localizedDescription ) } } /// Displays an alert to the user about the failure func alertingFailure () -> SelfCaught { return self . catchEscaping { alert ( error . localizedDescription ) } } } We can then use .printingFailure and .alertingFailure for both synchronous and asynchronous chains (corresponding to types Result<T> and Promise<T> ). For example, using our function .alertingFailure synchronously could look like this: let result = attempt { guard let something = something else { throw MockError . notImplemented } // ... }. alertingFailure (). result // do something with result Or we could use .alertingFailure asynchronously as well: let resultInt : Int = try await attempt { () -> Int guard let something = something else { throw MockError . notImplemented } // ... return 0 }. alertingFailure (). asyncThrows () Note You can see we use catchEscaping rather than catch when passing a non-async closure in a protocol context. This is the only time that catchEscaping should be preferred. The performance boost using catchEscaping is probably negligible though. If you'd like to keep it simple and only ever use catch , you would write the extension returning a CaughtPromise<T> or a PartiallyCaughtPromise<T> as follows: extension Catchable { func printingFailure () -> CaughtPromise < T > { return self . catch { error in print ( error . localizedDescription ) } } } // OR extension Catchable { func printingRethrowingFailure () -> PartiallyCaughtPromise < T > { return self . catch { error in print ( error . localizedDescription ) throw error } } } The only difference here is that the body passed to self.catch is treated as async , so a caught or uncaught variant of a Promise<T> is always returned. This means that you will never be able to call .result on the output as demonstrated earlier, but will have to use .asyncResult instead.","title":"Example: Modular failure blocks"},{"location":"motivation-and-common-patterns/#common-patterns","text":"How do I...","title":"Common Patterns"},{"location":"motivation-and-common-patterns/#run-two-chains-in-parallel","text":"async let value1 = attempt{ ... }.async() async let value2 = attempt{ ... }.async() You then round up the results by calling let values = await [value1, value2])","title":"Run two chains in parallel?"},{"location":"motivation-and-common-patterns/#use-a-chained-result-with-guard-statements","text":"guard let v : Person ? = await attempt { return try await api . GetPerson () }. recover { return try await localCache . GetPerson () }. catch { error in logger . error ( \"We could not get a person\" ) }. asyncOptional () else { }","title":"Use a chained result with guard statements?"},{"location":"operations/","text":"Operations \u00b6 Following is a full list of supported chaining operations in Async+: attempt \u00b6 Use attempt to start a chain of commands. The provided body will begin running immediately. The return type will be a Value<T> , Result<T> ( AsyncPlus.Result ), Guarantee<T> , or Promise<T> depending on the async/throwing status of the body closure. If the body passed to attempt does not return a value, you will get a Value<()> , AsyncPlus.Result<()> , Guarantee<()> , or Promise<()> as a return type. You usually do not work with these return types directly, but instead use chaining operations on them. attempt { < body > } then \u00b6 then takes a body closure to run that takes as input any results from earlier in the chain, and returns a value to pass along to later operations in the chain. The body closure can be async and/or throwing. If the closure does not return a value, any existing value from earlier in the chain are passed on automatically. . then { upstreamResult in < body > } or . then { upstreamResult -> OutType in < body > return < instance of OutType > } If you do not return a result from the closure, the result of the chaining operation is discardable, meaning that you will not get an unused value warning from Xcode if you choose to terminate the chain there. The return types are the same as attempt , based on the async/throwing status of the previous items in the chain, and the async/throwing status of the provided body. Again, you usually do not need to worry about the return type. recover \u00b6 The provided closure to recover recieves any errors, and can attempt to provide a \"backup\" or \"recovery\" value to fix the error. The provided closure may be async and/or throwing. Example using attempt , then , and recover : let photo = try await attempt { return await api . getPhoto () }. recover { err in return await cache . getPhoto () }. then { photo in try displayPhotoToUser ( photo ) }. asyncThrows () ensure \u00b6 Always runs the provided body in place with respect to the other chained operations, regardless of whether the chain has failed or succeeded. The body may be async but it may not throw. . ensure { < body > } catch \u00b6 Runs the provided body closure in the event that the chain fails. The error will be passed to the body closure, which may be async and/or throwing. If the body closure is throwing, a PartiallyCaughtPromise or a PartiallyCaughtResult will be returned, implying that a further catch call is required or the value of the chain must be used in some other way such as through a call to asyncThrows() . If the body closure does not throw, the result is discardable and returns a CaughtPromise or CaughtResult type. . catch { err in < body > throw OtherError () }. catch { err in < non - throwing body > } Once you call .catch on a chain, you can continue to chain on other calls to .catch , .ensure , but you will no longer be able to call .then or .recover on the chain to continue building its return value. If you wish to be able to do this, use .recover instead of .catch . finally \u00b6 finally may be run after a chain fully completes. The provided body closure may be async, but not throwing. finally will not be available for chains that have not fully caught any failures, or have not used results returned from the last then call. Once finally has been called, no more chained operations with body closures may follow. . finally { ... }","title":"Operations"},{"location":"operations/#operations","text":"Following is a full list of supported chaining operations in Async+:","title":"Operations"},{"location":"operations/#attempt","text":"Use attempt to start a chain of commands. The provided body will begin running immediately. The return type will be a Value<T> , Result<T> ( AsyncPlus.Result ), Guarantee<T> , or Promise<T> depending on the async/throwing status of the body closure. If the body passed to attempt does not return a value, you will get a Value<()> , AsyncPlus.Result<()> , Guarantee<()> , or Promise<()> as a return type. You usually do not work with these return types directly, but instead use chaining operations on them. attempt { < body > }","title":"attempt"},{"location":"operations/#then","text":"then takes a body closure to run that takes as input any results from earlier in the chain, and returns a value to pass along to later operations in the chain. The body closure can be async and/or throwing. If the closure does not return a value, any existing value from earlier in the chain are passed on automatically. . then { upstreamResult in < body > } or . then { upstreamResult -> OutType in < body > return < instance of OutType > } If you do not return a result from the closure, the result of the chaining operation is discardable, meaning that you will not get an unused value warning from Xcode if you choose to terminate the chain there. The return types are the same as attempt , based on the async/throwing status of the previous items in the chain, and the async/throwing status of the provided body. Again, you usually do not need to worry about the return type.","title":"then"},{"location":"operations/#recover","text":"The provided closure to recover recieves any errors, and can attempt to provide a \"backup\" or \"recovery\" value to fix the error. The provided closure may be async and/or throwing. Example using attempt , then , and recover : let photo = try await attempt { return await api . getPhoto () }. recover { err in return await cache . getPhoto () }. then { photo in try displayPhotoToUser ( photo ) }. asyncThrows ()","title":"recover"},{"location":"operations/#ensure","text":"Always runs the provided body in place with respect to the other chained operations, regardless of whether the chain has failed or succeeded. The body may be async but it may not throw. . ensure { < body > }","title":"ensure"},{"location":"operations/#catch","text":"Runs the provided body closure in the event that the chain fails. The error will be passed to the body closure, which may be async and/or throwing. If the body closure is throwing, a PartiallyCaughtPromise or a PartiallyCaughtResult will be returned, implying that a further catch call is required or the value of the chain must be used in some other way such as through a call to asyncThrows() . If the body closure does not throw, the result is discardable and returns a CaughtPromise or CaughtResult type. . catch { err in < body > throw OtherError () }. catch { err in < non - throwing body > } Once you call .catch on a chain, you can continue to chain on other calls to .catch , .ensure , but you will no longer be able to call .then or .recover on the chain to continue building its return value. If you wish to be able to do this, use .recover instead of .catch .","title":"catch"},{"location":"operations/#finally","text":"finally may be run after a chain fully completes. The provided body closure may be async, but not throwing. finally will not be available for chains that have not fully caught any failures, or have not used results returned from the last then call. Once finally has been called, no more chained operations with body closures may follow. . finally { ... }","title":"finally"}]}